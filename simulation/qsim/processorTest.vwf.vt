// Copyright (C) 2017  Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License 
// Subscription Agreement, the Intel Quartus Prime License Agreement,
// the Intel FPGA IP License Agreement, or other applicable license
// agreement, including, without limitation, that your use is for
// the sole purpose of programming logic devices manufactured by
// Intel and sold by Intel or its authorized distributors.  Please
// refer to the applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "12/04/2017 21:29:09"
                                                                                
// Verilog Test Bench (with test vectors) for design :                          processor
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module processor_vlg_vec_tst();
// constants                                           
// general purpose registers
reg clock;
reg reset;
// wires                                               
wire [1:0] aluASel;
wire [1:0] aluBSel;
wire aluInBDX;
wire aluInBF;
wire aluInBFD;
wire aluInBMW;
wire aluInBXM;
wire [4:0] aluOpDX;
wire [4:0] aluOpF;
wire [4:0] aluOpFD;
wire [4:0] aluOpMW;
wire [4:0] aluOpXM;
wire argsLessThanX;
wire argsNotEqualX;
wire [1:0] branchCtrlDX;
wire [1:0] branchCtrlF;
wire [1:0] branchCtrlFD;
wire [1:0] branchCtrlMW;
wire [1:0] branchCtrlXM;
wire [31:0] dMemInM;
wire [31:0] dMemOutM;
wire [31:0] dMemOutMW;
wire [11:0] dmem_address;
wire [31:0] dmem_data_in;
wire execErrorMW;
wire execErrorX;
wire execErrorXM;
wire execReadyX;
wire [31:0] execResultMW;
wire [31:0] execResultX;
wire [31:0] execResultXM;
wire [31:0] fetchInsn;
wire gatedClk;
wire [31:0] immDX;
wire [31:0] immF;
wire [31:0] immFD;
wire [31:0] immMW;
wire [31:0] immXM;
wire [1:0] jumpCtrlDX;
wire [1:0] jumpCtrlF;
wire [1:0] jumpCtrlFD;
wire [1:0] jumpCtrlMW;
wire [1:0] jumpCtrlXM;
wire loadDataDX;
wire loadDataF;
wire loadDataFD;
wire loadDataMW;
wire loadDataXM;
wire [31:0] nextPCX;
wire [4:0] opcodeDX;
wire [4:0] opcodeF;
wire [4:0] opcodeFD;
wire [4:0] opcodeMW;
wire [4:0] opcodeXM;
wire [31:0] pcDX;
wire [31:0] pcF;
wire [31:0] pcFD;
wire [31:0] pcMW;
wire pcOverrideX;
wire [31:0] pcXM;
wire [4:0] rdDX;
wire [4:0] rdF;
wire [4:0] rdFD;
wire [4:0] rdMW;
wire [4:0] rdXM;
wire [31:0] regAValByp;
wire [31:0] regAValD;
wire [31:0] regAValDX;
wire [31:0] regBValByp;
wire [31:0] regBValD;
wire [31:0] regBValDX;
wire [31:0] regBValXM;
wire regWriteEnDX;
wire regWriteEnF;
wire regWriteEnFD;
wire regWriteEnMW;
wire regWriteEnXM;
wire [31:0] regWriteValW;
wire [4:0] rsDX;
wire [4:0] rsF;
wire [4:0] rsFD;
wire [4:0] rsMW;
wire [4:0] rsXM;
wire [4:0] rtDX;
wire [4:0] rtF;
wire [4:0] rtFD;
wire [4:0] rtMW;
wire [4:0] rtXM;
wire setxCtrlDX;
wire setxCtrlF;
wire setxCtrlFD;
wire setxCtrlMW;
wire setxCtrlXM;
wire [4:0] shamtDX;
wire [4:0] shamtF;
wire [4:0] shamtFD;
wire [4:0] shamtMW;
wire [4:0] shamtXM;
wire storeDataDX;
wire storeDataF;
wire storeDataFD;
wire storeDataMW;
wire storeDataXM;
wire [31:0] targetDX;
wire [31:0] targetF;
wire [31:0] targetFD;
wire [31:0] targetMW;
wire [31:0] targetXM;
wire [4:0] writeRegW;
wire [1:0] writeSelectW;

// assign statements (if any)                          
processor i1 (
// port map - connection between master ports and signals/registers   
	.aluASel(aluASel),
	.aluBSel(aluBSel),
	.aluInBDX(aluInBDX),
	.aluInBF(aluInBF),
	.aluInBFD(aluInBFD),
	.aluInBMW(aluInBMW),
	.aluInBXM(aluInBXM),
	.aluOpDX(aluOpDX),
	.aluOpF(aluOpF),
	.aluOpFD(aluOpFD),
	.aluOpMW(aluOpMW),
	.aluOpXM(aluOpXM),
	.argsLessThanX(argsLessThanX),
	.argsNotEqualX(argsNotEqualX),
	.branchCtrlDX(branchCtrlDX),
	.branchCtrlF(branchCtrlF),
	.branchCtrlFD(branchCtrlFD),
	.branchCtrlMW(branchCtrlMW),
	.branchCtrlXM(branchCtrlXM),
	.clock(clock),
	.dMemInM(dMemInM),
	.dMemOutM(dMemOutM),
	.dMemOutMW(dMemOutMW),
	.dmem_address(dmem_address),
	.dmem_data_in(dmem_data_in),
	.execErrorMW(execErrorMW),
	.execErrorX(execErrorX),
	.execErrorXM(execErrorXM),
	.execReadyX(execReadyX),
	.execResultMW(execResultMW),
	.execResultX(execResultX),
	.execResultXM(execResultXM),
	.fetchInsn(fetchInsn),
	.gatedClk(gatedClk),
	.immDX(immDX),
	.immF(immF),
	.immFD(immFD),
	.immMW(immMW),
	.immXM(immXM),
	.jumpCtrlDX(jumpCtrlDX),
	.jumpCtrlF(jumpCtrlF),
	.jumpCtrlFD(jumpCtrlFD),
	.jumpCtrlMW(jumpCtrlMW),
	.jumpCtrlXM(jumpCtrlXM),
	.loadDataDX(loadDataDX),
	.loadDataF(loadDataF),
	.loadDataFD(loadDataFD),
	.loadDataMW(loadDataMW),
	.loadDataXM(loadDataXM),
	.nextPCX(nextPCX),
	.opcodeDX(opcodeDX),
	.opcodeF(opcodeF),
	.opcodeFD(opcodeFD),
	.opcodeMW(opcodeMW),
	.opcodeXM(opcodeXM),
	.pcDX(pcDX),
	.pcF(pcF),
	.pcFD(pcFD),
	.pcMW(pcMW),
	.pcOverrideX(pcOverrideX),
	.pcXM(pcXM),
	.rdDX(rdDX),
	.rdF(rdF),
	.rdFD(rdFD),
	.rdMW(rdMW),
	.rdXM(rdXM),
	.regAValByp(regAValByp),
	.regAValD(regAValD),
	.regAValDX(regAValDX),
	.regBValByp(regBValByp),
	.regBValD(regBValD),
	.regBValDX(regBValDX),
	.regBValXM(regBValXM),
	.regWriteEnDX(regWriteEnDX),
	.regWriteEnF(regWriteEnF),
	.regWriteEnFD(regWriteEnFD),
	.regWriteEnMW(regWriteEnMW),
	.regWriteEnXM(regWriteEnXM),
	.regWriteValW(regWriteValW),
	.reset(reset),
	.rsDX(rsDX),
	.rsF(rsF),
	.rsFD(rsFD),
	.rsMW(rsMW),
	.rsXM(rsXM),
	.rtDX(rtDX),
	.rtF(rtF),
	.rtFD(rtFD),
	.rtMW(rtMW),
	.rtXM(rtXM),
	.setxCtrlDX(setxCtrlDX),
	.setxCtrlF(setxCtrlF),
	.setxCtrlFD(setxCtrlFD),
	.setxCtrlMW(setxCtrlMW),
	.setxCtrlXM(setxCtrlXM),
	.shamtDX(shamtDX),
	.shamtF(shamtF),
	.shamtFD(shamtFD),
	.shamtMW(shamtMW),
	.shamtXM(shamtXM),
	.storeDataDX(storeDataDX),
	.storeDataF(storeDataF),
	.storeDataFD(storeDataFD),
	.storeDataMW(storeDataMW),
	.storeDataXM(storeDataXM),
	.targetDX(targetDX),
	.targetF(targetF),
	.targetFD(targetFD),
	.targetMW(targetMW),
	.targetXM(targetXM),
	.writeRegW(writeRegW),
	.writeSelectW(writeSelectW)
);
initial 
begin 
#2000000 $finish;
end 

// clock
always
begin
	clock = 1'b0;
	clock = #10000 1'b1;
	#10000;
end 

// reset
initial
begin
	reset = 1'b0;
end 
endmodule

